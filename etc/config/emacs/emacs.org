#+title: Literate Emacs Configuration
#+author: Brendan Desmond
#+babel: :cache yes
#+property: header-args :mkdirp yes :tangle "./init.el" :results silent
# org-hide-leading-stars: nil

* Set up this file

#+begin_src emacs-lisp
  (defun bd/org-tangle-on-config-save ()
    "Tangle source code blocks when configuration file is saved."
    (when (string= buffer-file-name (file-truename (concat user-emacs-directory "emacs.org")))
      (org-babel-tangle)))

  (add-hook 'after-save-hook #'bd/org-tangle-on-config-save)
#+end_src

* Early init
  :properties:
  :header-args+: :tangle "./early-init.el"
  :end:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; NOTE: This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file directly. Instead, edit its corresponding source block in `emacs.org'.
  ;;;
  ;;; Code:

  ;; UI
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (setq initial-frame-alist
        '((internal-border-width . 20)
          (ns-transparent-titlebar . t)))
  (setq default-frame-alist initial-frame-alist)
  (setq frame-inhibit-implied-resize t)
  (setq-default x-gtk-resize-child-frames 'resize-mode)

  ;; Increase GC threshold during startup for faster loading
  (defvar bd/gc-cons-threshold (* 16 1024 1024)) ;; 16MB default
  (defvar bd/gc-cons-percentage gc-cons-percentage)
  (defvar bd/file-name-handler-alist file-name-handler-alist)

  (setq gc-cons-threshold (* 64 1024 1024))    ; 64MB during init
  (setq gc-cons-percentage 0.6)                ; Default is 0.1
  (setq-default file-name-handler-alist nil)   ; Disable pattern handling
  (setq-default inhibit-compacting-font-caches t)

  ;; Restore normal values after init
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold bd/gc-cons-threshold
                    gc-cons-percentage bd/gc-cons-percentage)
              (setq-default file-name-handler-alist bd/file-name-handler-alist)))

  (defun bd/minibuffer-setup-hook ()
    (setq gc-cons-threshold (* 100 1024 1024)))

  (defun bd/minibuffer-exit-hook ()
    (setq gc-cons-threshold bd/gc-cons-threshold))

  (add-hook 'minibuffer-setup-hook #'bd/minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'bd/minibuffer-exit-hook)

  ;;
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)

  ;;
  (setq message-log-max (* 1024 32))  ;; 32K message log
  (setq debug-on-error t)             ;; Show stack trace on error

  ;;
  (dolist (dir '("lisp" "site-lisp"))
    (add-to-list 'load-path (concat user-emacs-directory dir)))

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* Package system

#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :init (package-refresh-contents t)
    :custom
    (package-archives
     '(("gnu" . "https://elpa.gnu.org/packages/")
       ("melpa" . "https://melpa.org/packages/")))
    (package-native-compile t))

  (use-package auto-package-update
    :ensure t
    :after package
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    (auto-package-update-delete-old-versions t)
    :config
    (auto-package-update-maybe)
    (auto-package-update-at-time "09:00"))
#+end_src

* Base settings

#+begin_src emacs-lisp
  ;;; Base System Settings
  ;; Core system behavior and environment
  (global-auto-revert-mode)
  (setq global-auto-revert-non-file-buffers t)
  (add-hook 'focus-out-hook #'garbage-collect)

  ;;
  (setq disabled-command-function nil)
  (setq load-prefer-newer t)
  (setq save-interprogram-paste-before-kill t)
  (setq next-error-message-highlight t)
  (setq use-short-answers t)

  ;;
  (when (eq system-type 'darwin)
    (use-package exec-path-from-shell
      :ensure t
      :config (exec-path-from-shell-initialize)))

  ;;; File Handling
  ;;
  (setq prefer-coding-system       'utf-8
        set-default-coding-systems 'utf-8
        set-language-environment   "UTF-8"
        set-locale-environment     "en_US.UTF-8")

  ;;
  (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
  (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
  (setq backup-by-copying t)
  (setq create-lockfiles nil)

  ;;; Session and History
  ;;
  (use-package desktop
    :custom (desktop-dirname user-emacs-directory)
    :config (desktop-save-mode 1))

  ;;
  (use-package saveplace
    :custom
    (save-place-file (concat user-emacs-directory "saveplace"))
    (save-place-forget-unreadable-files t)
    :config (save-place-mode 1))

  ;;
  (use-package savehist
    :custom
    (savehist-file (concat user-emacs-directory "savehist"))
    (history-length 1000)
    (history-delete-duplicates t)
    (savehist-save-minibuffer-history t)
    :config
    (savehist-mode 1))

  ;;
  (use-package recentf
    :custom
    (recentf-exclude '("/tmp/"))
    (recentf-max-saved-items 100)
    :config
    (recentf-mode 1))

  ;;
  (use-package uniquify
    :ensure nil
    :custom
    (uniquify-after-kill-buffer-p t)
    (uniquify-buffer-name-style 'forward)
    (uniquify-ignore-buffers-re "^\\*"))

  ;;
  (use-package ibuffer
    :ensure nil  ;; built-in
    :hook ((ibuffer-mode . ibuffer-auto-mode)
           (ibuffer-mode . hl-line-mode))
    :bind ("C-x C-b" . ibuffer)
    :custom
    (ibuffer-default-sorting-mode 'major-mode))
#+end_src

* User interface
** General
#+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (global-goto-address-mode 1)

  (setq battery-update-interval 60)
  (setq display-time-format "%a %b %e %H:%M")
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)

  (setq image-animate-loop t)
  (setq ring-bell-function 'ignore)
  (setq view-read-only t)

  ;; mouse
  (setq mouse-autoselect-window nil)
  (setq mouse-drag-and-drop-region t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  (setq mouse-wheel-tilt-scroll t)
  (setq mouse-yank-at-point t)

  ;; scrolling
  (pixel-scroll-precision-mode 1)
  (setq fast-but-imprecise-scrolling t)
  (setq scroll-conservatively 101)
  (setq scroll-margin 0)
  (setq scroll-preserve-screen-position t)

  (use-package scroll-lock
    :ensure nil
    :hook (help-mode . scroll-lock-mode)
    :bind
    (("<Scroll_Lock>" . #'scroll-lock-mode)
     (:map scroll-lock-mode-map
           ("j" . #'scroll-lock-next-line)
           ("k" . #'scroll-lock-previous-line)
           ("n" . #'scroll-lock-next-line)
           ("p" . #'scroll-lock-previous-line))))

  (use-package ansi-color
    :hook (compilation-filter . ansi-color-compilation-filter))

  (use-package simple
    :ensure nil
    :config
    (column-number-mode -1)
    (line-number-mode -1))

  (use-package display-line-numbers
    :ensure nil
    :bind (:map global-map ("C-c l" . #'display-line-numbers-mode))
    :custom
    (display-line-numbers-mode -1)
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))

  (use-package imenu
    :ensure nil
    :custom (imenu-auto-rescan t))

  (use-package outline
    :ensure nil
    :custom (outline-minor-mode-cycle t))

  (use-package hl-todo
    :ensure t
    :config (global-hl-todo-mode 1))

  (use-package man
    :ensure nil
    :hook (Man-mode-hook . scroll-lock-mode)
    :custom (Man-notify-method 'aggressive))

  (use-package which-key
    :ensure nil
    :config
    (which-key-mode 1))

  ;; Hide list of minor modes behind a menu.
  (use-package minions
    :ensure t
    :config (minions-mode 1))
#+end_src

** Font and text display

#+begin_src emacs-lisp
  ;; macOS font smoothing default: `defaults write org.gnu.Emacs AppleFontSmoothing -int 1`
  ;; look into (setq ns-use-thin-smoothing t)

  (use-package face-remap
    :ensure nil
    :config
    (setq text-scale-mode-step 1.05))

  (use-package faces
    :ensure nil
    :init
    (defface variable-pitch-serif
      '((((type w32))
         :family "Georgia" :foundry "outline")
        (t :family "Serif"))
      "The basic variable-pitch serif face."
      :group 'basic-faces)
    :config
    (set-face-attribute
     'variable-pitch-serif nil
     :family "Charter"
     :height (face-attribute 'variable-pitch :height)))

  (use-package fontaine
    :ensure t
    :bind (:map global-map ("C-c f" . #'fontaine-set-preset))
    :config
    (setq fontaine-presets
          '((macos
             :default-family "Menlo"
             :default-height 130
             :line-spacing 0.25)
            (linux
             :default-family "Meslo"
             :default-height 130
             :line-spacing 0.25)
            (input-narrow
             :default-family "Input Mono Narrow"
             :default-height 130
             :variable-pitch-family "Input Sans Narrow"
             :line-spacing 0.20)
            (input-narrow-inter
             :default-family "Input Mono Narrow"
             :default-height 130
             :line-spacing 0.20)
            (input
             :default-family "Input Mono"
             :default-height 130
             :variable-pitch-family "Input Sans"
             :line-spacing 0.20)
            (paper
             :default-family "Triplicate A Code"
             :default-height 140
             :variable-pitch-family "Charter"
             :variable-pitch-height 1.0
             :line-spacing 0.18)
            (scp-13
             :default-family "Source Code Pro"
             :default-weight normal
             :default-height 130
             :variable-pitch-height 1.05
             :variable-pitch-weight normal
             :line-spacing 0.10)
            ;; scp-14 looks best with:
            ;;`defaults write org.gnu.Emacs AppleFontSmoothing -int 0`
            (scp-14
             :inherit scp-13
             :variable-pitch-height 0.95
             :default-height 140)
            (scp-15
             :inherit scp-13
             :variable-pitch-height 0.9
             :default-height 150)
            (go
             :default-family "Go Mono"
             :default-height 130
             :variable-pitch-family "Lucida Grande"
             :line-spacing 0.20)
            (jb
             :default-family "JetBrains Mono"
             :default-height 130
             :line-spacing 0.15)
            (t
             :variable-pitch-family "Inter")))

    (advice-add 'fontaine-set-preset :after
                (lambda (&rest _)
                  (when (require 'org-variable-pitch nil t)
                    (when (fboundp 'org-variable-pitch-setup)
                      (with-temp-message "" (org-variable-pitch-setup))))))

    (let ((preset (if (eq system-type 'darwin) 'macos 'modern)))
      (fontaine-set-preset preset))

    (fontaine-mode 1))
#+end_src

** Variable pitch (nearly) everywhere

   I like coding in variable-width fonts, given that the font is a good one for that purpose. Examples include Input Sans and Input Sans Narrow.

   #+begin_src emacs-lisp
     (defvar bd/variable-pitch-modes
       '(text-mode
         conf-mode
         org-mode
         prog-mode
         dired-mode)
       "List of major modes that should use variable-pitch-mode.")

     (defvar bd/default-faces
       '(line-number line-number-current-line org-table)
       "Faces that should remain fixed-pitch even in variable-pitch-mode.")

     (defun bd/setup-default-faces ()
       "Make sure code elements stay fixed-pitch even in variable-pitch-mode."
       (dolist (face bd/default-faces)
         (set-face-attribute face nil :inherit 'default)))

     (defun bd/maybe-set-variable-pitch ()
       "Enable variable-pitch-mode if current major mode is in bd/variable-pitch-modes."
       (when (or (member major-mode bd/variable-pitch-modes)
                 (apply #'derived-mode-p bd/variable-pitch-modes))
         (variable-pitch-mode 1)))

     (defun bd/setup-variable-pitch-hooks ()
       "Set up hooks for variable-pitch-mode."
       (add-hook 'after-change-major-mode-hook #'bd/maybe-set-variable-pitch))

     (defun bd/variable-pitch-setup ()
       "Set up all font-related configurations."
       (bd/setup-default-faces)
       (bd/setup-variable-pitch-hooks))

     ;; (bd/variable-pitch-setup)
   #+end_src

** Theme

#+begin_src emacs-lisp
  (setq custom-safe-themes t)
  (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))

  (defadvice load-theme (before clear-previous-themes activate)
    "Clear existing theme settings instead of layering them."
    (mapc #'disable-theme custom-enabled-themes))

  (when (display-graphic-p)
    (use-package calm-themes
      :load-path "themes/calm-themes"
      :config
      (load-theme 'calm-white t)
      ;; :bind ("C-c t r" . calm-load-theme)
      ))

  (use-package auto-dark
    ;; breaking on certain setups—emacs not visible in security events settings
    :ensure t
    :after calm-themes
    :config (auto-dark-mode)
    :custom
    (auto-dark-allow-osascript t)
    (auto-dark-light-theme 'calm-white)
    (auto-dark-dark-theme 'calm-dark))
#+end_src

** Frames

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t)
  (setq frame-resize-pixelwise t)
  (setq frame-title-format
        (list (format "%%j ")
              '(buffer-file-name "%f"(dired-directory dired-directory "%b"))))
  (setq mode-line-compact nil)
  (setq ns-use-proxy-icon nil)
#+end_src

** Window management
#+begin_src emacs-lisp
  ;; Emacs' default way of handling windows is bad. See: https://github.com/nex3/perspective-el#some-musings-on-emacs-window-layouts
  ;; TODO use prot's setup to learn how to modify =display-buffer-alist=
  ;;   - make a list of behaviors you want to change
  ;; TODO =display-buffer-same-window= breaks magit commit window behavior so turn it off for now.

  (setq display-buffer-alist
        '(
          ;; ("\\*Help.*"
          ;; (display-buffer-in-side-window)
          ;; (display-buffer-reuse-window display-buffer-in-side-window))
          ;; (side . top)
          ;; (slot . 0))
          ("magit-diff.*\\|\\*r\\|\\*helm.*\\*"
           (display-buffer-reuse-window
            display-buffer-pop-up-window))
          ("\\*\\(output\\|Register Preview\\).*"
           (display-buffer-at-bottom))
          ;; ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
          ;; (display-buffer-reuse-window)
          ;; (display-buffer-same-window)
          ;; )
          ))

  (setq even-window-sizes nil) ; display-buffer: avoid resizing
  (setq help-window-select t)
  (setq window-combination-resize t)

  (winner-mode 1)

  ;; Try the super key to avoid conflicts with org-mode.
  (windmove-default-keybindings 'super)
  (define-key global-map (kbd "s-J") #'windmove-down)
  (define-key global-map (kbd "s-K") #'windmove-up)
  (define-key global-map (kbd "s-H") #'windmove-left)
  (define-key global-map (kbd "s-L") #'windmove-right)

  (defun bd/window-swap-with-next (arg)
    "Swap current window with the next one."
    (interactive "p")
    (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
      (while (/= arg 0)
        (let ((this-win (window-buffer))
              (next-win (window-buffer (funcall selector))))
          (set-window-buffer (selected-window) next-win)
          (set-window-buffer (funcall selector) this-win)
          (select-window (funcall selector)))
        (setq arg (if (cl-plusp arg) (1- arg) (1+ arg))))))
  (define-key global-map (kbd "C-c 5") #'bd/window-swap-with-next)

  ;; Use keyboard shortcuts to grow/shrink windows intuitively.
  (require 'smart-window-resize)

  (global-set-key (kbd "C-s-h") (lambda () (interactive) (smart-adjust-window-width 'left 5)))
  (global-set-key (kbd "C-s-l") (lambda () (interactive) (smart-adjust-window-width 'right 5)))
  (global-set-key (kbd "C-s-k") (lambda () (interactive) (smart-adjust-window-height 'up 5)))
  (global-set-key (kbd "C-s-j") (lambda () (interactive) (smart-adjust-window-height 'down 5)))
    ;;; finer adjustments
  (global-set-key (kbd "C-M-s-h") (lambda () (interactive) (smart-adjust-window-width 'left 1)))
  (global-set-key (kbd "C-M-s-l") (lambda () (interactive) (smart-adjust-window-width 'right 1)))
  (global-set-key (kbd "C-M-s-k") (lambda () (interactive) (smart-adjust-window-height 'up 1)))
  (global-set-key (kbd "C-M-s-j") (lambda () (interactive) (smart-adjust-window-height 'down 1)))
    ;;;
  (global-set-key (kbd "C-s-0") (lambda () (interactive) (balance-windows)))

  (use-package rotate
    :ensure t
    :bind (("C-c 6"    . #'rotate-layout)
           ("C-c C-\\" . #'rotate:even-horizontal)
           ("C-c C--"  . #'rotate:even-vertical)))
#+end_src

** Minibuffer

#+begin_src emacs-lisp
  ;;; Cancel minibuffer regardless of whether you're in it.
  (defun bd/keyboard-quit-dwim ()
    "Do-What-I-Mean behaviour for a general `keyboard-quit'.

  The generic `keyboard-quit' does not do the expected thing when
  the minibuffer is open.  Whereas we want it to close the
  minibuffer, even without explicitly focusing it.

  The DWIM behaviour of this command is as follows:

  - When the region is active, disable it.
  - When a minibuffer is open, but not focused, close the minibuffer.
  - When the Completions buffer is selected, close it.
  - In every other case use the regular `keyboard-quit'."
    (interactive)
    (cond
     ((region-active-p)
      (keyboard-quit))
     ((derived-mode-p 'completion-list-mode)
      (delete-completion-window))
     ((> (minibuffer-depth) 0)
      (abort-recursive-edit))
     (t
      (keyboard-quit))))
  (global-set-key [remap keyboard-quit] #'bd/keyboard-quit-dwim)

  (use-package minibuffer
    :ensure nil
    :custom
    (completion-styles '(basic partial-completion emacs22 substring flex))
    (completion-ignore-case t)
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles . (partial-completion)))))
    (enable-recursive-minibuffers t)
    (read-file-name-completion-ignore-case t)
    (read-buffer-completion-ignore-case t))

  (use-package vertico
    :ensure t
    :init
    (advice-add
     #'vertico--setup :after
     (lambda (&rest _)
       (setq-local completion-auto-help nil
                   completion-show-inline-help nil)))
    :config
    (icomplete-mode -1)
    (fido-mode -1)
    (vertico-mode 1))

  (use-package vertico-posframe
    :disabled
    :after vertico
    :ensure t
    :custom
    (vertico-posframe-parameters
     '((left-fringe . 10)
       (right-fringe . 10)))
    :config (vertico-posframe-mode 1))

  (use-package icomplete
    :ensure nil
    :custom
    (ido-enable-flex-matching t)
    :config
    ;; Stop ido from suggesting when naming new file
    (when (boundp 'ido-minor-mode-map-entry)
      (define-key (cdr ido-minor-mode-map-entry) [remap write-file] nil))

    (unless (bound-and-true-p vertico-mode)
      (fido-vertical-mode)))

  (use-package orderless
    :ensure t
    :init (add-to-list 'completion-styles 'orderless)
    :custom (completion-category-overrides nil))

  (use-package marginalia
    :ensure t
    :config (marginalia-mode))
#+end_src

** tab-bar

#+begin_src emacs-lisp
  (use-package tab-bar
    :preface
    (defun bd/toggle-stats-in-tab-bar ()
      "Toggle time and battery display in tab-bar based on fullscreen state."
      (let ((fullscreen (eq (frame-parameter nil 'fullscreen) 'fullboth))
            (has-right-align (member 'tab-bar-format-align-right tab-bar-format))
            (has-global (member 'tab-bar-format-global tab-bar-format)))
        (cond
         ;; Enable stats when fullscreen and not already enabled
         ((and fullscreen (not has-right-align))
          (setq tab-bar-format
                (append tab-bar-format
                        '(tab-bar-format-align-right tab-bar-format-global)))
          (display-battery-mode 1)
          (display-time-mode 1))
         ;; Disable stats when not fullscreen but currently enabled
         ((and (not fullscreen) (or has-right-align has-global))
          (setq tab-bar-format
                (seq-remove (lambda (element)
                              (memq element '(tab-bar-format-align-right
                                              tab-bar-format-global)))
                            tab-bar-format))
          (display-time-mode -1)
          (display-battery-mode -1))))
      (tab-bar--update-tab-bar-lines))

    (defun bd/compact-tab-bar--format-tab (orig-fn tab i)
      "Wrap `tab-bar--format-tab' to compress whitespace between tabs."
      (let* ((tabs (funcall tab-bar-tabs-function))
             (prev (when (> i 1)
                     (nth (1- i) tabs)))
             (tab-bg (or (face-background 'tab-bar) "unspecified"))
             (tab-bar-separator
              (cond
               ;; no separator before the first tab
               ((= i 1)
                (propertize " "
                            'display '((space :width 0))))
               ;; for current-tab <-> adjacent, draw 1-col of background
               ((or (eq (car tab) 'current-tab)
                    (eq (car prev) 'current-tab))
                (propertize (or tab-bar-separator " ")
                            ;; inherit the bar's background so it "erases"
                            'face `(:background ,tab-bg)))
               ;; otherwise, fall back to the usual separator
               (t
                (or tab-bar-separator " ")))))
        (funcall orig-fn tab i)))

    (defun bd/compact-tab-bar-suffix ()
      "Prevent tabs filling the remainder of the tab bar."
      " ")

    :init
    (add-hook 'window-size-change-functions (lambda (_) (bd/toggle-stats-in-tab-bar)))
    (advice-add 'tab-bar--format-tab :around #'bd/compact-tab-bar--format-tab)

    :config
    (setq tab-bar-format '(tab-bar-format-tabs bd/compact-tab-bar-suffix))
    (setq tab-bar-auto-width nil)
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-new-button-show nil)
    (setq tab-bar-new-tab-choice "*Ibuffer*")
    (setq tab-bar-new-tab-to 'rightmost)
    (setq tab-bar-tab-hints t)
    (setq tab-bar-close-button
     (propertize (if (char-displayable-p ?×) "  ×  " "  x  ")
                 'close-tab t
                 'mouse-face 'tab-bar-close-highlight
                 'help-echo "Click to close tab"))

    :bind
    (("s-{" . tab-bar-switch-to-prev-tab)
     ("s-}" . tab-bar-switch-to-next-tab)
     ("s-T" . tab-bar-new-tab)
     ("s-W" . tab-bar-close-tab)))

  ;; bd/compact-tab-bar should do the trick
  (use-package emacs-modern-tab-bar
    :ensure t
    :disabled t
    :after tab-bar
    :vc (:url "https://github.com/aaronjensen/emacs-modern-tab-bar"
              :branch "master")
    :config
    (defvar modern-tab-bar--recursion-prevention nil
      "Flag to prevent recursion in modern-tab-bar functions.")

    (advice-add 'modern-tab-bar-mode :around
                (lambda (orig-fun &rest args)
                  (if modern-tab-bar--recursion-prevention
                      nil  ;; Skip if we're already in the midst of operations
                    (let ((modern-tab-bar--recursion-prevention t))
                      (apply orig-fun args)))))

    (advice-add 'modern-tab-bar--enable-theme :around
                (lambda (orig-fun &rest args)
                  (if modern-tab-bar--recursion-prevention
                      nil  ;; Skip if we're already in the midst of operations
                    (let ((modern-tab-bar--recursion-prevention t))
                      (apply orig-fun args)))))
    )
#+end_src

** tab-line

#+begin_src emacs-lisp
  (use-package tab-line
    :custom
    (tab-line-close-button-show t)
    (tab-line-new-button-show nil)
    (tab-line-separator "")
    (tab-line-tab-name-function #'bd/tab-line-name-buffer)
    (tab-line-switch-cycling t)
    (tab-line-new-tab-choice "*Ibuffer*")
    (tab-line-tab-hints nil)
    (tab-line-close-button
          (propertize (if (char-displayable-p ?×) "  ×  " "  x  ")
                      'keymap tab-line-tab-close-map
                      'mouse-face 'tab-line-close-highlight
                      'help-echo "Click to close tab"))
    (tab-line-right-button
          (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                      'keymap tab-line-right-map
                      'mouse-face 'tab-line-highlight
                      'help-echo "Click to scroll right"))
    (tab-line-left-button
          (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                      'keymap tab-line-left-map
                      'mouse-face 'tab-line-highlight
                      'help-echo "Click to scroll left"))
    :config
    (define-key global-map (kbd "s-[") 'tab-line-switch-to-prev-tab)
    (define-key global-map (kbd "s-]") 'tab-line-switch-to-next-tab))

  ;; Resize tabs automatically
  ;;
  ;; https://andreyorst.gitlab.io/posts/2020-05-10-making-emacs-tabs-look-like-in-atom/
  ;;
  ;; First, we will need two variables - one for minimum width, and one for
  ;; maximum width. I like to define variables that extend some built-in packages
  ;; via defcustom because if someone else will use my config they will be able to
  ;; customize such things with the custom interface or via code. Also Custom
  ;; makes persistent configurations a bit easier as well.
  (defcustom tab-line-tab-min-width 15
    "Minimum width of a tab in characters."
    :type 'integer
    :group 'tab-line)

  (defcustom tab-line-tab-max-width 30
    "Maximum width of a tab in characters."
    :type 'integer
    :group 'tab-line)

  ;; The second thing we need is to produce a valid name for the tab, but right
  ;; now we will simply string-trim buffer name, and calculate its width. This
  ;; should leave us with these computations:
  (defun bd/tab-line-name-buffer (buffer &rest _buffers)
    (with-current-buffer buffer
      (let* ((window-width (window-width (get-buffer-window)))
             (close-button-size (if tab-line-close-button-show
                                    (length (substring-no-properties tab-line-close-button))
                                  0))
             (tab-amount (length (tab-line-tabs-window-buffers)))
             (window-max-tab-width (/ window-width tab-amount))
             (tab-width (- (cond ((>= window-max-tab-width tab-line-tab-max-width)
                                  tab-line-tab-max-width)
                                 ((< window-max-tab-width tab-line-tab-min-width)
                                  tab-line-tab-min-width)
                                 (t window-max-tab-width))
                           close-button-size))
             (buffer-name (string-trim (buffer-name)))
             (name-width (length buffer-name)))

        ;; Now, when we have all this information, we can compute the name for the tab
        ;; and its paddings. First, we need to check if the trimmed buffer name exceeds
        ;; the tab width. If it is, we truncate the name to the width of the tab minus
        ;; 3, because we need to add single space padding before a name and add an
        ;; ellipsis symbol followed by a space at the end.
        (if (>= name-width (- tab-width 3))
            (concat  " " (truncate-string-to-width buffer-name (- tab-width 3)) "… ")

          ;; If name-width is less than tab-width minus 3, we can produce left padding, by
          ;; computing difference between tab-width and name-width, and dividing it by
          ;; 2. Then we concatenate this padding and calculate the right padding needed
          ;; for the name. This extra calculation is needed when a name is odd or even, so
          ;; we produce equally sized tabs for any buffer name:
          (let* ((padding (make-string (/ (- tab-width name-width) 2) ?\s))
                 (buffer-name (concat padding buffer-name))
                 (name-width (length buffer-name)))
            (concat buffer-name (make-string (- tab-width name-width) ?\s)))))))

  ;; Turns out there's a way to update tab width on resize events by clearing the
  ;; cache of tab-line in each window. As a quite dirty hack, we can use this hook:
  (add-hook 'window-configuration-change-hook
            #'(lambda ()
                (dolist (window (window-list))
                  (set-window-parameter window 'tab-line-cache nil))))
#+end_src

** Colorize color strings (rainbow-mode)

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer t
    :custom
    (rainbow-r-colors nil)
    (rainbow-x-colors nil)
    (rainbow-ansi-colors nil)
    (rainbow-html-colors nil))
#+end_src

** Consult
#+begin_src emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;;
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Tweak the register preview for `consult-register-load',
    ;; `consult-register-store' and the built-in commands.  This improves the
    ;; register formatting, adds thin separator lines, register sorting and hides
    ;; the window mode line.
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    
    :config
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep consult-man
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Makes only the open buffers list visible when calling consult-buffer command
    ;; by hiding the other sources, but still allowing the narrowing to recent files
    ;; (by typing f SPC), bookmarks (m SPC) and project buffer and/or files (p SPC).
    (dolist (src consult-buffer-sources)
    (unless (eq src 'consult--source-buffer)
      (set src (plist-put (symbol-value src) :hidden t))))
    
    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
  )
#+end_src

* Text editing
** General

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default fill-column 80)
  (setq-default tab-width 4)
  (setq-default word-wrap t)
  (setq default-input-method "greek") ; `C-\` changes to Greek
  (setq kill-whole-line t) ; don't just clear it
  (setq mac-right-option-modifier 'none) ; for special "Option" character input
  (setq mode-require-final-newline 'visit-save)
  (setq require-final-newline t)
  (setq sentence-end-double-space nil)

  (add-hook 'after-init-hook #'electric-indent-mode)
  (add-hook 'after-init-hook #'electric-pair-mode)
  (add-hook 'after-init-hook #'show-paren-mode)
  (add-hook 'before-ave-hook #'whitespace-cleanup)

  (dolist (hook '(prog-mode-hook conf-space-mode-hook))
    (add-hook hook (lambda () (setq show-trailing-whitespace t))))

  (use-package align
    :ensure nil
    :bind (:map global-map ("C-c a". #'align-regexp)))

  (use-package delsel
    :ensure nil
    :hook (after-init . delete-selection-mode))

  (use-package hippie-exp
    :ensure nil
    :bind (:map global-map ("M-/" . #'hippie-expand)))

  (use-package misc
    :ensure nil
    :bind (:map global-map ("M-z" . #'zap-up-to-char))
    :config
    (autoload 'zap-up-to-char "misc"
      "Kill up to, but not including ARGth occurrence of CHAR." t))

  (use-package simple
    :ensure nil
    :config
    (dolist (hook '(comint-mode-hook
                    shell-mode-hook
                    help-mode-hook
                    debugger-mode-hook
                    org-mode-hook
                    text-mode-hook
                    nov-mode-hook
                    cider-repl-mode-hook))
      (add-hook hook #'visual-line-mode))
    (add-hook 'prog-mode-hook (lambda () (visual-line-mode -1))))

  (use-package highlight-indent-guides
    :ensure t
    :bind (:map global-map ("C-c ;" . #'highlight-indent-guides-mode))
    :config
    (setq highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line)
    (setq highlight-indent-guides-method 'bitmap)
    (setq highlight-indent-guides-responsive nil))

  (use-package hungry-delete
    :ensure t
    :config (global-hungry-delete-mode 1))

  (use-package idle-highlight
    :ensure nil
    :hook (prog-mode . idle-highlight-mode))

  ;; evil-mode `J` makes this redundant
  (defun bd/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line
        of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))
#+end_src

** evil-mode

My brain and hands are held hostage to vim keys indefinitely. However, they often conflict with other interfaces in Emacs, and I am not a "vim everywhere" type of person anymore. I want to keep its conventions relegated strictly to editing and navigating text.

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :preface
    (defun bd/evil-modes-init ()
      ;; i don't know why these modes don't start in emacs state
      (dolist (mode '(comint-mode
                      eshell-mode
                      shell-mode
                      inferior-ess-mode
                      help-mode))
        (evil-set-initial-state mode 'emacs))
      (dolist (mode '(eww-mode prog-mode text-mode conf-mode org-mode))
        (evil-set-initial-state mode 'normal)))

    (defun bd/evil-keys-init ()
      (define-key evil-normal-state-map (kbd "SPC") #'evil-scroll-page-down)
      (define-key evil-normal-state-map (kbd "DEL") #'evil-scroll-page-up)
      (dolist (map '(help-mode-map eww-mode-map))
        (evil-define-key 'normal map (kbd "<tab>") #'next-button)
        (evil-define-key 'normal map (kbd "S-<tab>") #'previous-button))
      (evil-define-key 'normal org-mode-map (kbd "<tab>") #'org-cycle))

    :custom
    (evil-default-state 'emacs)

    :config
    (evil-set-undo-system 'undo-redo)
    (bd/evil-modes-init)
    (bd/evil-keys-init)
    (evil-mode 1))
#+end_src

** Auto-completion with ~corfu~

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :hook
    ((eshell-mode prog-mode org-mode shell-mode) . corfu-mode)
    ((eshell-mode prog-mode org-mode shell-mode) . (lambda () (setq-local corfu-auto t)))
    :bind (:map corfu-map
                ("\r" . bd/corfu-insert-and-send))
    :custom
    (corfu-preview-current nil)
    (corfu-quit-no-match 'separator)
    (tab-always-indent 'complete)
    :config
    (corfu-history-mode)
    (corfu-popupinfo-mode)

    (defun bd/corfu-insert-and-send ()
      (interactive)
      (corfu-insert)
      (cond
       ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
        (eshell-send-input))
       ((derived-mode-p 'comint-mode)
        (comint-send-input)))))
#+end_src

** Text

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook (lambda () (auto-fill-mode -1)))
  (add-hook 'text-mode-hook (lambda () (setq fill-column 72)))
  (dolist
      (mapping '(("\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\|INSTALL\\)$" . text-mode)
                 ("\\(.gitignore\\)$" . conf-mode)
                 ("\\.git/config\\'" . conf-mode)))
    (add-to-list 'auto-mode-alist mapping))
#+end_src

** Git commits

As far as I can tell, git-commit-mode hooks should be run after text-mode hooks since git-commit-mode is a minor mode in a text-mode buffer.

#+begin_src emacs-lisp
(add-hook 'git-commit-mode-hook #'auto-fill-mode)
(add-hook 'git-commit-mode-hook (lambda () (visual-line-mode -1)))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t
    :init (add-hook 'markdown-mode-hook (lambda () (setq indent-tabs-mode nil)))
    :custom
    (markdown-command "multimarkdown")
    (markdown-fontify-code-blocks-natively t)
    :config
    (when (bound-and-true-p evil-mode)
      (evil-define-key 'normal markdown-mode-map (kbd "<tab>") #'markdown-cycle)))

  (use-package markdown-preview-mode
    :ensure t
    :defer t
    :requires markdown-mode)

  (use-package markdown-preview-eww
    :ensure t
    :defer t
    :requires markdown-mode)
#+end_src

** TeX

#+begin_src emacs-lisp
  (use-package tex
    :ensure auctex
    :defer t
    :init (setq-default TeX-master nil)
    :custom
    (TeX-auto-save t)
    (TeX-parse-self t)
    (font-latex-fontify-sectioning 'color))
#+end_src

** Shell scripts

#+begin_src emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq indent-tabs-mode nil)
              (setq tab-width 2)))
#+end_src

** Go

#+begin_src emacs-lisp
  (use-package go-mode
    :ensure t
    :defer t
    :config (add-hook 'before-save-hook #'gofmt-before-save)
    :hook (go-mode . (lambda () (setq tab-width 4))))
#+end_src

** Hoon

#+begin_src emacs-lisp
  (use-package hoon-mode
    :ensure t
    :disabled t
    :defer t
    :vc (:url "https://github.com/brendes/hoon-mode.el"
         :branch "master")
    :preface
    (defun bd/hoon-mode ()
      (lambda ()
        (setq tab-width 2)
        (setq eldoc-echo-area-prefer-doc-buffer t)))
    :hook (hoon-mode . #'bd/hoon-mode)
    :bind (:map hoon-mode-map
            ("C-c r" . #'hoon-eval-region-in-herb)
            ("C-c b" . #'hoon-eval-buffer-in-herb)))
#+end_src

** Emacs and Common Lisp

#+begin_src emacs-lisp
  (dolist (hook '(lisp-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook (lambda () (setq fill-column 80)))
    (add-hook hook (lambda () (setq indent-tabs-mode nil))))

  (use-package slime
    :ensure t
    :defer t
    :custom (inferior-lisp-program "sbcl"))
#+end_src

** Clojure

#+begin_src emacs-lisp
(add-hook 'cider-repl-mode-hook #'visual-line-mode)
#+end_src

** Python

#+begin_src emacs-lisp
  (use-package elpy
    :ensure t
    :defer t
    :config (elpy-enable 1))
#+end_src

** R: ESS (Emacs Speaks Statistics)

#+begin_src emacs-lisp
  (use-package ess
    :ensure t
    :defer t
    :init
    (dolist (hook '(r-mode-hook ess-mode-hook))
      (add-hook hook #'(lambda () (setq tab-width 2 indent-tabs-mode nil))))
    :bind (:map ess-r-mode-map ("C-c R" . #'run-ess-r))
    :custom
    (ess-set-style 'RStudio))
#+end_src

** Scala

#+begin_src emacs-lisp
(use-package scala-mode :ensure t :defer t)
#+end_src

* Version control

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)

  (use-package magit
    :ensure t
    :defer t
    :bind ("C-c g" . #'magit-status)
    :custom (magit-save-repository-buffers 'dontask)

  (use-package diff-hl
    :ensure t
    :init
    (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh))
    (add-hook 'dired-mode-hook #'diff-hl-dired-mode)
    :config (global-diff-hl-mode 1))
#+end_src

* Applications and utilities
** File management

Delete files by moving them to the system's Trash directory.
For macOS, this requires an additional package.

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash t)

  (if (eq system-type 'darwin)
      (use-package osx-trash
        :ensure t
        :init (osx-trash-setup))
    (use-package trashed
      :ensure t
      :commands (trashed)
      :config
      (setq trashed-action-confirmer 'y-or-n-p)
      (setq trashed-use-header-line t)
      (setq trashed-sort-key '("Date deleted" . t))
      (setq trashed-date-format "%Y-%m-%d %H:%M:%S")))

#+end_src

Setup =dired=, Emacs' directory editor.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :init (put 'dired-find-alternate-file 'disabled nil)
    :commands (dired)
    :hook
    ((dired-mode . auto-revert-mode)
     (dired-mode . dired-hide-details-mode)
     (dired-mode . hl-line-mode))
    :bind
    (:map dired-mode-map
          ("C-x C-j"   . #'dired-jump)
          ("s-j"       . #'dired-jump)
          ("C-x 4 C-j" . #'dired-jump-other-window)
          ("s-J"       . #'dired-jump-other-window)
          ("j"         . #'next-line)
          ("k"         . #'previous-line)
          ("J"         . #'dired-goto-file)
          ("K"         . #'dired-do-kill-lines)
          ("h"         . #'dired-up-directory)
          ("l"         . #'bd/dired-open-or-toggle-subtree)
          ("r"         . #'dired-do-redisplay)
          ("-"         . #'dired-up-directory))
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-find-subdir t)
    (dired-hide-details-hide-information-lines t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-kill-when-opening-new-dired-buffer t)
    (dired-listing-switches "-alhF")
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    (delete-by-moving-to-trash t))

  (use-package dired-aux
    :custom
    (dired-create-destination-dirs 'ask)
    (dired-vc-rename-file t))

  (use-package dired-x :custom (dired-clean-up-buffers-too t))

  (use-package async
    :ensure t
    :defer t
    :init (autoload 'dired-async-mode "dired-async.el" nil t)
    :config (dired-async-mode 1))

  (use-package dired-subtree
    :ensure t
    :defer t
    :preface
    (defun bd/dired-open-or-toggle-subtree ()
      (interactive)
      (if (file-directory-p (dired-get-file-for-visit))
          (if (featurep 'dired-subtree)
              (dired-subtree-toggle)
            (dired-find-file))
        (dired-find-file)))
    :config
    (setq dired-subtree-use-backgrounds nil)
    (setq dired-subtree-line-prefix "  ")
    :bind
    (:map dired-mode-map
          ("<tab>"     . #'dired-subtree-toggle)
          ("<C-tab>"   . #'dired-subtree-cycle)
          ("<backtab>" . #'dired-subtree-remove)))

  (use-package image-dired
    :ensure t
    :defer t
    :bind
    (:map image-dired-thumbnail-mode-map
          ("<return>" . #'image-dired-thumbnail-display-external)))

  (use-package dired-sidebar :ensure t :defer t)

  ;; open file in gui from dired
  (with-eval-after-load "dired"
    (define-key dired-mode-map (kbd "z")
                (lambda () (interactive)
                  (let ((fn (dired-get-file-for-visit)))
                    (if (eq system-type 'darwin)
                        (start-process "default-app" nil "open" fn)
                      (start-process "default-app" nil "xdg-open" fn))))))
#+end_src

** Process management with =proced=

#+begin_src emacs-lisp
(add-hook 'proced-mode-hook #'hl-line-mode)
#+end_src

** Shells and terminal emulators
*** shell-mode and comint-mode

#+begin_src emacs-lisp
  (use-package comint
    :ensure nil
    :init
    ;; disable ansi color codes
    (add-to-list 'comint-output-filter-functions #'ansi-color-process-output)
    ;; better directory tracking
    (add-to-list 'comint-output-filter-functions #'comint-osc-process-output)
    :hook
    ((comint-mode shell-mode) . (lambda () (setq comint-move-point-for-output nil))))

  (use-package native-complete :ensure t)

  (use-package comint-mime
    :ensure t
    :after comint)
#+end_src

*** General terminal emulation

#+begin_src emacs-lisp
  ;; As recommended in =term.el= source code
  (add-hook 'term-mode-hook
            (lambda ()
              (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
              (setq-local mouse-yank-at-point t)
              (setq-local transient-mark-mode nil)
              (auto-fill-mode -1)
              (setq tab-width 8)))
#+end_src

*** vterm

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :bind
    (("C-c t" . #'vterm)
     (:map vterm-mode-map ("C-y" . #'vterm-yank)))
    :custom
    (vterm-buffer-name-string "vterm: %s")
    (vterm-max-scrollback 100000)
    :config
    (setq-local evil-move-cursor-back nil))

  (use-package vterm-toggle
    :requires vterm
    :ensure t
    :bind ("C-c T" . #'vterm-toggle-cd))

  (defun bd/select-shell-mode-buffer ()
    "Select from a list of shell or terminal emulation buffers."
    (interactive)
    (let* ((shell-modes '(vterm-mode eshell-mode shell-mode term-mode))
           (shell-buffers (cl-remove-if-not
                           (lambda (buf)
                             (with-current-buffer buf
                               (memq major-mode shell-modes)))
                           (buffer-list))))
      (switch-to-buffer
       (completing-read "Shell buffers: "
                        (mapcar #'buffer-name shell-buffers)))))

  (define-key global-map (kbd "C-c s") #'bd/select-shell-mode-buffer)
#+end_src

*** eshell

#+begin_src emacs-lisp
  (use-package eshell
    :bind (("C-c e" . eshell))

    :custom
    (eshell-error-if-no-glob t)
    (eshell-history-size 10000)
    (eshell-hist-ignoredups t)
    (eshell-ls-use-colors nil)
    (eshell-save-history-on-exit t)
    (eshell-destroy-buffer-when-process-dies t)
    (eshell-prefer-lisp-functions nil)
    (eshell-banner-message "")
    (eshell-aliases-file nil)

    :config
    (add-hook 'eshell-mode-hook (lambda () (setq outline-regexp eshell-prompt-regexp)))
    (add-hook 'eshell-mode-hook
              (lambda ()
                (eshell/alias "d" "dired $1")
                (eshell/alias "e" "find-file $1")
                (eshell/alias "eo" "find-file-other-window $1")
                (eshell/alias "ls" "ls -F $*")
                (eshell/alias "l" "ls -a $*")
                (eshell/alias "ll" "ls -la $*")
                (eshell/alias "ltr" "ls -latr $*")
                (eshell/alias "cp" "cp -i $*")
                (eshell/alias "rm" "rm -i $*")
                (eshell/alias "mv" "mv -i $*")
                (eshell/alias "less" "view-file $1")
                (eshell/alias "view" "view-file $1")
                (eshell/alias "gs" "magit-status")
                (eshell/alias "gd" "magit-diff-unstaged")
                (eshell/alias "gp" "magit-push-current-to-pushremote")
                (eshell/alias "gc" "magit-commit")
                (eshell/alias "c" "clear")))

    (defun bd/eshell-prompt-function ()
      (let ((current-branch
             (when (and (fboundp 'magit-get-current-branch)
                        (magit-get-current-branch))
               (concat " ["
                       (magit-get-current-branch)
                       "]"))))
        (concat
         (abbreviate-file-name (eshell/pwd))  ; Current path
         (or current-branch "")
         (if (= (user-uid) 0) " # " " $ "))))  ; Prompt indicator

    (setq eshell-prompt-function 'bd/eshell-prompt-function)
    (setq eshell-prompt-regexp "^[^#$\n]* [#$] ")

    (defun eshell/clear ()
      "Clear the eshell buffer."
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))

    (advice-add 'eshell/ls :around
                (lambda (orig-fun &rest args)
                  (let ((args (cond
                               ((and (boundp 'ls-lisp-use-insert-directory-program)
                                     ls-lisp-use-insert-directory-program)
                                (cons "--color=never" args))
                               (t args))))
                    (apply orig-fun args))))
    )

  (use-package eshell-vterm
    ;; run any command in visual mode
    :ensure t
    :demand t
    :after eshell
    :preface (defalias 'eshell/v #'eshell-exec-visual)
    :config (eshell-vterm-mode))
#+end_src

*** Enable Emacs shortcuts inside terminal buffers

#+begin_src emacs-lisp
  (use-package term
    :bind (:map term-raw-map
           ;; Force Emacs keys in term's char-mode
           ("C-s" . #'isearch-forward-regexp)
           ("C-r" . #'isearch-backward-regexp)
           ("C-y" . #'term-paste)
           ("M-x" . #'execute-extended-command)
           ("M-:" . #'eval-expression)
           :map term-raw-escape-map
           ("M-x" . #'execute-extended-command)
           ("M-:" . #'eval-expression)))
#+end_src

** Tramp

#+begin_src emacs-lisp
  (use-package tramp
    :ensure nil
    ;; reported to be faster
    :config (setq tramp-default-method "ssh"))
#+end_src

** Org-mode

#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :preface
    (defun bd/org-emphasize-dwim (&optional char)
      "Add org emphasis markers to word at point."
      (interactive)
      (unless (region-active-p)
        (backward-word)
        (mark-word))
      (org-emphasize char))

    (defun bd/org-insert-datetree ()
      "Manually insert org datetree header for the current date."
      (interactive)
      (org-datetree-find-date-create
       (org-date-to-gregorian (format-time-string "%Y-%m-%d")))
      (newline))

    ;; https://github.com/hkjels/elemental/blob/master/elemental.org
    (defun bd/narrow-or-widen-dwim ()
      "If narrowed, widen. Otherwise, it narrows to region, org-source or
    org subtree."
      (interactive)
      (cond ((buffer-narrowed-p) (widen))
            ((org-src-edit-buffer-p) (org-edit-src-exit))
            ((region-active-p) (narrow-to-region (region-beginning) (region-end)))
            ((equal major-mode 'org-mode)
             (cond ((ignore-errors (org-edit-src-code)) t)
                   (t (org-narrow-to-subtree))))
            (t (error "Please select a region to narrow to"))))

    ;; https://stackoverflow.com/questions/25161792/emacs-org-mode-how-can-i-fold-everything-but-the-current-headline
    (defun bd/org-show-current-heading-tidily ()
      (interactive)
      "Show next entry, keeping other entries closed."
      (if (save-excursion (end-of-line) (outline-invisible-p))
          (progn (org-show-entry) (show-children))
        (outline-back-to-heading)
        (unless (and (bolp) (org-on-heading-p))
          (org-up-heading-safe)
          (hide-subtree)
          (error "Boundary reached"))
        (org-overview)
        (org-reveal t)
        (org-show-entry)
        (show-children)))

    :hook
    (org-mode . org-indent-mode)
    (org-mode . (lambda () (auto-fill-mode 0)))
    (org-mode . (lambda () (setq indent-tabs-mode nil)))

    :init
    (defvar org-preview-latex-process-alist nil
      "Placeholder for compatibility with ob-latex.")

    :bind
    ("C-c c" . org-capture)
    (:map org-mode-map
          ("C-c d" . bd/org-insert-datetree)
          ("C-c i" . org-toggle-inline-images)
          ("C-c p" . bd/org-emphasize-dwim)
          ("C-c n" . bd/org-narrow-or-widen-dwim))

    :custom
    (org-agenda-files (list (concat org-directory "/")))
    (org-agenda-window-setup 'current-window)
    (org-adapt-indentation 'headline-data)
    (org-babel-load-languages
     '((R          . t)
       (C          . t)
       (clojure    . t)
       (ditaa      . t)
       (dot        . t)
       (emacs-lisp . t)
       (gnuplot    . t)
       (haskell    . t)
       (latex      . t) ; this is causing problems and i don't know why
       (lisp       . t)
       (org        . t)
       (shell      . t)
       (sql        . t)
       (sqlite     . t)))
    (org-catch-invisible-edits 'show)
    (org-capture-templates
     '(("t" "Todo" entry
        (file+headline (lambda () (concat org-directory "/" "todo.org")) "Tasks")
        "* TODO %?\n  %U\n  %i")))
    (org-default-notes-file (concat org-directory "/notes.org"))
    (org-fontify-quote-and-verse-blocks t)
    (org-image-actual-width nil)
    (org-latex-compiler "xelatex")
    (org-latex-inputenc-alist '(("utf8" . "utf8x")))
    (org-latex-listings 'minted)
    (org-latex-pdf-process '("latexmk -xelatex -quiet -shell-escape -f %f"))
    (org-latex-toc-command "\\tableofcontents \\clearpage")
    (org-link-descriptive nil)
    (org-list-allow-alphabetical t)
    (org-log-into-drawer t)
    (org-refile-targets `((nil :maxlevel . 3) (org-agenda-files :maxlevel . 3)))
    (org-src-fontify-natively t)
    (org-src-preserve-indentation nil)
    (org-src-tab-acts-natively t)
    (org-src-window-setup 'current-window)
    (org-todo-keywords '((sequence "TODO(t)" "IN PROGRESS(s)" "|" "DONE(d!/!)")
                         (sequence "WAITING(w@/!)" "ON HOLD(h@/!)" "|"
                                   "POSTPONED(p!/!)" "CANCELLED(c@/!)")))

    :config
    ;; Make windmove active in locations where the shift-arrow keys don't have
    ;; functionality in org-mode.
    ;;
    ;; NOTE: Consider trying `(setq org-replace-disputed-keys t)` instead -- then
    ;; we won't have to worry about whether or not we're sitting on a headline or
    ;; list item.
    (add-hook 'org-shiftup-final-hook 'windmove-up)
    (add-hook 'org-shiftleft-final-hook 'windmove-left)
    (add-hook 'org-shiftdown-final-hook 'windmove-down)
    (add-hook 'org-shiftright-final-hook 'windmove-right))

  (use-package org-agenda
    :ensure nil
    :after org
    :hook (org-agenda-mode . hl-line-mode))

  (use-package org-tempo
    :ensure nil
    :after org
    :config
    (dolist (entry '(("el" . "src emacs-lisp")
                     ("R"  . "src r")
                     ("S"  . "src sh")))
      (add-to-list 'org-structure-template-alist entry)))

  (use-package org-bullets
    :ensure t
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("●" "○" "✸" "✿")))

  (use-package org-variable-pitch
    :ensure t
    :after org
    :preface
    (defun bd/ovp-line-spacing ()
      (when (<= line-spacing 3) (setq-local line-spacing 0.3)))
    :hook
    (after-init . org-variable-pitch-setup)
    (org-mode . org-variable-pitch-setup)
    (org-mode . org-variable-pitch-minor-mode)
    (org-variable-pitch-minor-mode . bd/ovp-line-spacing))

  (use-package ob-async
    :ensure t
    :after org)
#+end_src

** Writing

#+begin_src emacs-lisp
  (use-package olivetti
    :ensure t
    :defer t
    :config
    (when (<= 3 line-spacing)
      (setq-local line-spacing 0.3))
    :custom
    (olivetti-body-width 80))
#+end_src

** Gnus

#+begin_src emacs-lisp
  (use-package gnus
    :hook
    (gnus-group-mode . gnus-topic-mode)
    (gnus-select-group . gnus-group-set-timestamp)
    ((gnus-group-mode gnus-summary-mode gnus-browse-mode) . hl-line-mode)

    :config
    ;; Set UI-specific thread indicators when in GUI mode
    (when window-system
      (setq gnus-sum-thread-tree-root "● "
            gnus-sum-thread-tree-false-root "▷ "
            gnus-sum-thread-tree-single-indent ""
            gnus-sum-thread-tree-leaf-with-other "├─►"
            gnus-sum-thread-tree-vertical "│ "
            gnus-sum-thread-tree-single-leaf "└─►"))
    :custom

    (gnus-select-method '(nntp "news.gmane.io"))
    (gnus-max-image-proportion 0.7)
    (gnus-summary-line-format "%U%R %-18,18&user-date; %-25,25f %B%s\n")
    (gnus-asynchronous t)
    (gnus-use-article-prefetch 15))
#+end_src

** HTML and web browsing

#+begin_src emacs-lisp
  (use-package eww
    :ensure nil
    :preface
    (defun bd/eww-readable ()
      "Use more opinionated `eww-readable'.
  Set width to `current-fill-column'. Adjust size of images."
      (interactive)
      (let ((shr-width (current-fill-column))
            (shr-max-image-proportion 0.35))
        (eww-readable)))

    :bind (:map dired-mode-map ("E" . eww-open-file))

    :hook
    (eww-mode . scroll-lock-mode)
    (eww-bookmark-mode . hl-line-mode)

    :custom
    (browse-url-browser-function #'eww-browse-url)
    (browse-url-secondary-browser-function #'browse-url-default-browser)
    (eww-restore-desktop t))

  (use-package shr
    :ensure nil
    :config
    (setq shr-use-colors nil)
    (setq shr-max-image-proportion 0.6))
#+end_src

** Tabular or comma-separated data

#+begin_src emacs-lisp
  (use-package tabulated-list
    :ensure nil
    :hook
    ((tabulated-list-mode . display-line-numbers-mode)
     (tabulated-list-mode . hl-line-mode)))

  (use-package csv-mode
    :ensure t
    :defer t
    :hook
    ((csv-mode . hl-line-mode)
     (csv-mode . display-line-numbers-mode)))

  (use-package hl-line
    :ensure nil
    :mode
    (("\\.bed\\'" . hl-line-mode)
     ("\\.interval_list\\'" . hl-line-mode)
     ("\\.vcf\\'" . hl-line-mode))
    :config (setq hl-line-sticky-flag nil))
#+end_src

** PDFs

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :mode
    ("\\.pdf\\'" . pdf-view-mode)

    :hook
    (pdf-view-mode . (lambda () (cua-mode 0) (display-line-numbers-mode -1)))

    :preface
    (defun bd/update-pdf-view-colors (&rest _args)
      "Update `pdf-view-midnight-colors` based on current theme colors."
      (setq pdf-view-midnight-colors
            (cons (face-attribute 'default :foreground)
                  (face-attribute 'default :background))))

    (defun bd/pdf-view-scroll-boundary-advice (orig-fun &rest args)
      "Safely handle scrolling at document boundaries."
      (condition-case nil
          (apply orig-fun args)
        (error
         (let ((err-msg (if (equal (car args) -1)
                            "Beginning of document"
                          "End of document")))
           (message err-msg)))))

    (defun bd/pdf-view-mwheel-scroll-advice (orig-fun &rest args)
      "Safely handle mouse wheel events in PDF documents."
      (let ((event (car args)))
        (if (and (eq major-mode 'pdf-view-mode)
                 (or (memq (car-safe event) '(triple-wheel-down wheel-down triple-wheel-up wheel-up))))
            (condition-case nil
                (apply orig-fun args)
              (error
               (let ((err-msg (if (memq (car-safe event) '(triple-wheel-up wheel-up))
                                  "Beginning of document"
                                "End of document")))
                 (message err-msg))))
          (apply orig-fun args))))

    :init
    (advice-add 'load-theme :after #'bd/update-pdf-view-colors)
    (advice-add 'pdf-view-next-page :around #'bd/pdf-view-scroll-boundary-advice)
    (advice-add 'mwheel-scroll :around #'bd/pdf-view-mwheel-scroll-advice)

    :config
    (pdf-tools-install)

    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-regex-forward)
                ("C-r" . isearch-regex-reverse))

    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-resize-factor 1.1)
    (pdf-view-continuous t))
#+end_src

** Viewing EPUB files (nov.el)

#+begin_src emacs-lisp
  (use-package nov
    :ensure t
    :mode ("\\.epub\\'" . nov-mode)
    :hook (nov-mode . bd/nov-font-setup)
    :preface
    (defun bd/nov-font-setup ()
      (face-remap-add-relative
       'variable-pitch
       :family (face-attribute 'variable-pitch-serif :family)
       :height 1.0))
    :custom
    (visual-fill-column-center-text t))
#+end_src

** Music and audio (bongo)

#+begin_src emacs-lisp
  (use-package bongo
    :ensure t
    :hook ((bongo-library-mode bongo-playlist-mode) . hl-line-mode))
#+end_src

** RSS reader (elfeed)

#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :hook ((elfeed-show-mode . scroll-lock-mode)
           (elfeed-show-mode . (lambda () (setq shr-inhibit-images nil))))
    :custom
    (elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory))
    (elfeed-search-title-max-width 100))

  (use-package elfeed-org
    :ensure t
    :after elfeed)
#+end_src

* Machine-local config and custom file

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)

  (add-to-list 'load-path (expand-file-name "local/" user-emacs-directory))
  (require 'local-config)
#+end_src

